{"ast":null,"code":"var mediaRecorder = {};\nvar chunks = [];\nexport function startAudioRecording() {\n  // Ensure getUserMedia is supported\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    console.log('getUserMedia supported.');\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }) // Success callback, start recording\n    .then(stream => startRecording(stream)) // Error callback\n    .catch(function (err) {\n      console.log('The following getUserMedia error occured: ' + err);\n    });\n  } else {\n    console.log('getUserMedia not supported on your browser!');\n  }\n}\n\nfunction startRecording(stream) {\n  // Start recording\n  mediaRecorder = new MediaRecorder(stream);\n  mediaRecorder.start(10); // Start visualizing audio\n  // visualize(stream);\n\n  console.log(\"recorder started\");\n\n  mediaRecorder.ondataavailable = function (e) {\n    chunks.push(e.data);\n  };\n}\n\nexport function stopAudioRecording(filename) {\n  // Stop recording\n  mediaRecorder.stop();\n  console.log(mediaRecorder.state);\n  console.log(\"recorder stopped\");\n\n  mediaRecorder.onstop = e => stopRecording(e, filename);\n}\n\nfunction stopRecording(e, filename) {\n  // Stop and save the recording\n  console.log(\"recorder onstopped\");\n  const blob = new Blob(chunks, {\n    'type': 'audio/wav;'\n  }); // Format data to send to server\n\n  var reader = new FileReader();\n  reader.readAsDataURL(blob);\n\n  reader.onload = function (event) {\n    var base64AudioMessage = event.target.result.split(',')[1]; // Send audio blob to server\n\n    fetch('/api/audio', {\n      method: 'POST',\n      body: JSON.stringify({\n        filename: 'hello.wav',\n        audiostring: base64AudioMessage\n      }),\n      headers: new Headers({\n        'content-type': 'application/json'\n      })\n    }).then(response => response.json()).then(result => {\n      // Print result\n      console.log(result);\n    });\n  };\n\n  chunks = [];\n  /*\n  const clipName = prompt('Enter a name for your sound clip');\n   const clipContainer = document.createElement('article');\n  const clipLabel = document.createElement('p');\n  const audio = document.createElement('audio');\n  const deleteButton = document.createElement('button');\n    \n  const soundClips = document.querySelector('.sound-clips');    \n   clipContainer.classList.add('clip');\n  audio.setAttribute('controls', '');\n  deleteButton.innerHTML = \"Delete\";\n  clipLabel.innerHTML = clipName;\n   clipContainer.appendChild(audio);\n  clipContainer.appendChild(clipLabel);\n  clipContainer.appendChild(deleteButton);\n  soundClips.appendChild(clipContainer);\n   audio.controls = true;\n  const blob = new Blob(chunks, { 'type' : 'audio/wav;' });\n  \n  chunks = [];\n  const audioURL = window.URL.createObjectURL(blob);\n  audio.src = audioURL;\n   deleteButton.onclick = function(e) {\n    let evtTgt = e.target;\n    evtTgt.parentNode.parentNode.removeChild(evtTgt.parentNode);\n  }\n  */\n}\n\nfunction visualize(stream) {\n  // Visualize audio stream\n  const canvas = document.querySelector('.visualizer');\n  const canvasCtx = canvas.getContext(\"2d\");\n  let audioCtx;\n\n  if (!audioCtx) {\n    audioCtx = new AudioContext();\n  }\n\n  const source = audioCtx.createMediaStreamSource(stream);\n  const analyser = audioCtx.createAnalyser();\n  analyser.fftSize = 2048;\n  const bufferLength = analyser.frequencyBinCount;\n  const dataArray = new Uint8Array(bufferLength);\n  source.connect(analyser); //analyser.connect(audioCtx.destination);\n\n  draw();\n\n  function draw() {\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n    requestAnimationFrame(draw);\n    analyser.getByteTimeDomainData(dataArray);\n    canvasCtx.fillStyle = 'rgb(200, 200, 200)';\n    canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n    canvasCtx.lineWidth = 2;\n    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\n    canvasCtx.beginPath();\n    let sliceWidth = WIDTH * 1.0 / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i++) {\n      let v = dataArray[i] / 128.0;\n      let y = v * HEIGHT / 2;\n\n      if (i === 0) {\n        canvasCtx.moveTo(x, y);\n      } else {\n        canvasCtx.lineTo(x, y);\n      }\n\n      x += sliceWidth;\n    }\n\n    canvasCtx.lineTo(canvas.width, canvas.height / 2);\n    canvasCtx.stroke();\n  }\n}","map":{"version":3,"sources":["/Users/vascoxu/Desktop/smash/mohs/frontend/src/Components/audio.js"],"names":["mediaRecorder","chunks","startAudioRecording","navigator","mediaDevices","getUserMedia","console","log","audio","then","stream","startRecording","catch","err","MediaRecorder","start","ondataavailable","e","push","data","stopAudioRecording","filename","stop","state","onstop","stopRecording","blob","Blob","reader","FileReader","readAsDataURL","onload","event","base64AudioMessage","target","result","split","fetch","method","body","JSON","stringify","audiostring","headers","Headers","response","json","visualize","canvas","document","querySelector","canvasCtx","getContext","audioCtx","AudioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","bufferLength","frequencyBinCount","dataArray","Uint8Array","connect","draw","WIDTH","width","HEIGHT","height","requestAnimationFrame","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","v","y","moveTo","lineTo","stroke"],"mappings":"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","sourcesContent":["var mediaRecorder = {};\nvar chunks = [];\n\nexport function startAudioRecording() {\n  // Ensure getUserMedia is supported\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    console.log('getUserMedia supported.');\n    navigator.mediaDevices.getUserMedia (\n      {\n        audio: true\n      })\n\n      // Success callback, start recording\n      .then((stream) => startRecording(stream))\n\n      // Error callback\n      .catch(function(err) {\n        console.log('The following getUserMedia error occured: ' + err);\n      }\n    );\n  } else {\n    console.log('getUserMedia not supported on your browser!');\n  }\n}\n\nfunction startRecording(stream) {\n    // Start recording\n    mediaRecorder = new MediaRecorder(stream);\n    mediaRecorder.start(10);\n\n    // Start visualizing audio\n    // visualize(stream);\n\n    console.log(\"recorder started\");\n\n    mediaRecorder.ondataavailable = function(e) {\n      chunks.push(e.data);\n    }\n}\n\nexport function stopAudioRecording(filename) {\n  // Stop recording\n  mediaRecorder.stop();\n  console.log(mediaRecorder.state);\n  console.log(\"recorder stopped\");\n  mediaRecorder.onstop = (e) => stopRecording(e, filename);\n}\n\nfunction stopRecording(e, filename) {\n  // Stop and save the recording\n  console.log(\"recorder onstopped\");\n  const blob = new Blob(chunks, { 'type' : 'audio/wav;' });\n\n  // Format data to send to server\n  var reader = new FileReader();\n  reader.readAsDataURL(blob);\n  reader.onload = function(event) {\n    var base64AudioMessage = event.target.result.split(',')[1];\n\n    // Send audio blob to server\n    fetch('/api/audio', {\n      method: 'POST',\n      body: JSON.stringify({\n        filename: 'hello.wav',\n        audiostring: base64AudioMessage\n      }),\n      headers: new Headers({ 'content-type': 'application/json' })\n    })\n    .then(response => response.json())\n    .then(result => {\n      // Print result\n      console.log(result);\n    });\n  }\n\n  chunks = [];\n\n  /*\n  const clipName = prompt('Enter a name for your sound clip');\n\n  const clipContainer = document.createElement('article');\n  const clipLabel = document.createElement('p');\n  const audio = document.createElement('audio');\n  const deleteButton = document.createElement('button');\n    \n  const soundClips = document.querySelector('.sound-clips');    \n\n  clipContainer.classList.add('clip');\n  audio.setAttribute('controls', '');\n  deleteButton.innerHTML = \"Delete\";\n  clipLabel.innerHTML = clipName;\n\n  clipContainer.appendChild(audio);\n  clipContainer.appendChild(clipLabel);\n  clipContainer.appendChild(deleteButton);\n  soundClips.appendChild(clipContainer);\n\n  audio.controls = true;\n  const blob = new Blob(chunks, { 'type' : 'audio/wav;' });\n  \n  chunks = [];\n  const audioURL = window.URL.createObjectURL(blob);\n  audio.src = audioURL;\n\n  deleteButton.onclick = function(e) {\n    let evtTgt = e.target;\n    evtTgt.parentNode.parentNode.removeChild(evtTgt.parentNode);\n  }\n  */\n}\n\nfunction visualize(stream) {\n  // Visualize audio stream\n  const canvas = document.querySelector('.visualizer');\n  const canvasCtx = canvas.getContext(\"2d\");\n  let audioCtx;\n\n  if(!audioCtx) {\n    audioCtx = new AudioContext();\n  }\n\n  const source = audioCtx.createMediaStreamSource(stream);\n\n  const analyser = audioCtx.createAnalyser();\n  analyser.fftSize = 2048;\n  const bufferLength = analyser.frequencyBinCount;\n  const dataArray = new Uint8Array(bufferLength);\n\n  source.connect(analyser);\n  //analyser.connect(audioCtx.destination);\n\n  draw()\n\n  function draw() {\n    const WIDTH = canvas.width\n    const HEIGHT = canvas.height;\n\n    requestAnimationFrame(draw);\n\n    analyser.getByteTimeDomainData(dataArray);\n\n    canvasCtx.fillStyle = 'rgb(200, 200, 200)';\n    canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    canvasCtx.lineWidth = 2;\n    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\n\n    canvasCtx.beginPath();\n\n    let sliceWidth = WIDTH * 1.0 / bufferLength;\n    let x = 0;\n\n\n    for(let i = 0; i < bufferLength; i++) {\n\n      let v = dataArray[i] / 128.0;\n      let y = v * HEIGHT/2;\n\n      if(i === 0) {\n        canvasCtx.moveTo(x, y);\n      } else {\n        canvasCtx.lineTo(x, y);\n      }\n\n      x += sliceWidth;\n    }\n\n    canvasCtx.lineTo(canvas.width, canvas.height/2);\n    canvasCtx.stroke();\n\n  }\n}"]},"metadata":{},"sourceType":"module"}